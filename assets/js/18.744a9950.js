(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{574:function(t,a,s){t.exports=s.p+"assets/img/9E028EF0-1051-4A69-B6AE-3F88852D2F55.9ee647e2.png"},575:function(t,a,s){t.exports=s.p+"assets/img/50933E20-2BA8-4236-AF93-6B7412F5F5CC.dbba1752.png"},576:function(t,a,s){t.exports=s.p+"assets/img/C4F6D86C-8BD8-4C20-99D4-220DDB4C50CE.d7c6e072.png"},577:function(t,a,s){t.exports=s.p+"assets/img/3D5DF613-E179-4487-804C-3C8E54E1B8D5.dff64f1b.png"},578:function(t,a,s){t.exports=s.p+"assets/img/411CC472-456C-4087-9C1D-00960FB2C6D0.5ef86797.png"},579:function(t,a,s){t.exports=s.p+"assets/img/BCFB1857-B727-4EBC-957A-6D3D9B96D7F5.8ee7010b.png"},719:function(t,a,s){"use strict";s.r(a);var v=s(44),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"内存管理之一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理之一"}},[t._v("#")]),t._v(" 内存管理之一")]),t._v(" "),v("h2",{attrs:{id:"内存管理功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理功能"}},[t._v("#")]),t._v(" 内存管理功能")]),t._v(" "),v("h3",{attrs:{id:"存储器功能要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储器功能要求"}},[t._v("#")]),t._v(" 存储器功能要求")]),t._v(" "),v("ul",[v("li",[t._v("容量足够大")]),t._v(" "),v("li",[t._v("速度足够快")]),t._v(" "),v("li",[t._v("信息永久保存")]),t._v(" "),v("li",[t._v("多道程序并行")])]),t._v(" "),v("h3",{attrs:{id:"多道并行的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多道并行的问题"}},[t._v("#")]),t._v(" 多道并行的问题")]),t._v(" "),v("ul",[v("li",[t._v("共享：代码和数据共享，节省内存")]),t._v(" "),v("li",[t._v("保护：不允许内存中的程序相互非法访问")])]),t._v(" "),v("h3",{attrs:{id:"存储体系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储体系"}},[t._v("#")]),t._v(" 存储体系")]),t._v(" "),v("ol",[v("li",[t._v("三级存储体系")])]),t._v(" "),v("p",[v("img",{attrs:{src:s(574),alt:"9ee647e22587b74ca435512349319b51"}})]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("组成\n"),v("ul",[v("li",[t._v("cache：快、小、贵")]),t._v(" "),v("li",[t._v("内存：适中")]),t._v(" "),v("li",[t._v("辅存：慢、大、廉价")])])]),t._v(" "),v("li",[t._v("基本原理\n"),v("ul",[v("li",[t._v("内存不够用时，用辅存来支援内存")]),t._v(" "),v("li",[t._v("暂时不运行的模块切换到辅存上，必要时再切回内存")])])])]),t._v(" "),v("h3",{attrs:{id:"存储管理的功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储管理的功能"}},[t._v("#")]),t._v(" 存储管理的功能")]),t._v(" "),v("h4",{attrs:{id:"地址映射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#地址映射"}},[t._v("#")]),t._v(" 地址映射")]),t._v(" "),v("p",[t._v("将程序中的地址（虚拟地址、逻辑地址）变换成内存中的真实地址（实地址、物理地址）。")]),t._v(" "),v("h4",{attrs:{id:"三种地址映射方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三种地址映射方式"}},[t._v("#")]),t._v(" 三种地址映射方式")]),t._v(" "),v("ol",[v("li",[t._v("固定地址映射：编译或编程时确定逻辑地址和物理地址的映射关系，比如编程时就直接制定物理地址。")]),t._v(" "),v("li",[t._v("静态地址映射：程序装入的时候，由操作系统完成逻辑地址到物理地址映射，比如双击exe的时候，程序装入内存，操作系统进行地址映射。")])]),t._v(" "),v("p",[t._v("例子：有一段程序，其虚拟地址空间为"),v("br")]),v("div",{attrs:{align:"center"}},[v("br"),t._v(" "),v("img",{attrs:{src:s(575),width:"30%",height:"30%",alt:"图片名称"}}),v("br")]),v("p"),t._v(" "),v("p",[t._v("在程序装入的时候，将这块虚拟地址空间整体移动到真实物理内存中，起始位置是BA（基址，Base Addr.），如下图所示:"),v("br")]),v("div",{attrs:{align:"center"}},[v("br"),t._v(" "),v("img",{attrs:{src:s(576),width:"30%",height:"30%",alt:"图片名称"}}),v("br")]),v("p"),t._v(" "),v("p",[t._v("此时，"),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",[v("semantics",[v("mrow",[v("mi",[t._v("M")]),v("mi",[t._v("A")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("MA")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"strut",staticStyle:{height:"0.68333em"}}),v("span",{staticClass:"strut bottom",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),v("span",{staticClass:"base textstyle uncramped"},[v("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.10903em"}},[t._v("M")]),v("span",{staticClass:"mord mathit"},[t._v("A")])])])]),t._v("（物理地址） = "),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",[v("semantics",[v("mrow",[v("mi",[t._v("B")]),v("mi",[t._v("A")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("BA")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"strut",staticStyle:{height:"0.68333em"}}),v("span",{staticClass:"strut bottom",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),v("span",{staticClass:"base textstyle uncramped"},[v("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.05017em"}},[t._v("B")]),v("span",{staticClass:"mord mathit"},[t._v("A")])])])]),t._v("（基址） + "),v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",[v("semantics",[v("mrow",[v("mi",[t._v("V")]),v("mi",[t._v("A")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("VA")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"strut",staticStyle:{height:"0.68333em"}}),v("span",{staticClass:"strut bottom",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),v("span",{staticClass:"base textstyle uncramped"},[v("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.22222em"}},[t._v("V")]),v("span",{staticClass:"mord mathit"},[t._v("A")])])])]),t._v("（虚拟地址）")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("动态地址映射：在程序执行过程中完成地址映射。")])]),t._v(" "),v("p",[t._v("例如：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("MOV AX，[500] //访问500单元时执行地址映射\n")])])]),v("p",[t._v("这个过程中，如果程序有移动，BA可能发生改变，需要自动计算新的MA，程序占用的内存空间可以动态变化，这样程序不要求连续的内存空间，只要每段放置的基址能够知道。")]),t._v(" "),v("h4",{attrs:{id:"虚拟存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟存储"}},[t._v("#")]),t._v(" 虚拟存储")]),t._v(" "),v("p",[t._v("解决的问题是，当程序过大或者过多的时候，内存不够，无法运行；多个程序并发时地址冲突，不能运行。"),v("br"),t._v("\n虚拟内存是面向用户的虚拟封闭存储空间，是一个线性的地址空间，程序员进行编程时都是使用线性的虚拟地址。")]),t._v(" "),v("h4",{attrs:{id:"内存分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[t._v("#")]),t._v(" 内存分配")]),t._v(" "),v("p",[t._v("需要解决的问题：")]),t._v(" "),v("ul",[v("li",[t._v("放置策略：程序调入内存时将其放置在哪个内存区")]),t._v(" "),v("li",[t._v("调入策略：何时把要运行的代码和要访问的数据调入内存")]),t._v(" "),v("li",[t._v("淘汰策略：内存空间不够时，迁出/淘汰哪些代码或数据以腾出内存空间")])]),t._v(" "),v("h4",{attrs:{id:"存储保护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储保护"}},[t._v("#")]),t._v(" 存储保护")]),t._v(" "),v("p",[t._v("保证内存的多道程序只在给定的存储区内活动并互不干扰。")]),t._v(" "),v("h2",{attrs:{id:"物理内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#物理内存管理"}},[t._v("#")]),t._v(" 物理内存管理")]),t._v(" "),v("h3",{attrs:{id:"分区内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区内存管理"}},[t._v("#")]),t._v(" 分区内存管理")]),t._v(" "),v("ul",[v("li",[t._v("单一区存储管理（不分区存储管理）：用户区不分区，完全被一个程序占用，例如DOS")]),t._v(" "),v("li",[t._v("分区存储管理\n"),v("ol",[v("li",[t._v("固定分区：内存固定划分为大小不等的区域，有个分区表进行维护")]),t._v(" "),v("li",[t._v("动态分区：程序装入的时候创建分区，使得分区的大小刚好与程序的大小相等，有一些很小的空间无法利用，成为内存碎片")])])])]),t._v(" "),v("p",[t._v("这是一个固定分区的例子："),v("br")]),v("div",{attrs:{align:"center"}},[v("br"),t._v(" "),v("img",{attrs:{src:s(577),width:"30%",height:"30%",alt:"图片名称"}}),v("br")]),v("br"),t._v("\n上图代表内存空间，下图是内存分区表"),v("p"),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("区号")]),t._v(" "),v("th",[t._v("大小")]),t._v(" "),v("th",[t._v("起址")]),t._v(" "),v("th",[t._v("标志")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("1")]),t._v(" "),v("td",[t._v("16K")]),t._v(" "),v("td",[t._v("20K")]),t._v(" "),v("td",[t._v("已分配")])]),t._v(" "),v("tr",[v("td",[t._v("2")]),t._v(" "),v("td",[t._v("32K")]),t._v(" "),v("td",[t._v("36K")]),t._v(" "),v("td",[t._v("已分配")])]),t._v(" "),v("tr",[v("td",[t._v("3")]),t._v(" "),v("td",[t._v("64K")]),t._v(" "),v("td",[t._v("68K")]),t._v(" "),v("td",[t._v("已分配")])]),t._v(" "),v("tr",[v("td",[t._v("4")]),t._v(" "),v("td",[t._v("124K")]),t._v(" "),v("td",[t._v("132K")]),t._v(" "),v("td",[t._v("未分配")])])])]),t._v(" "),v("h3",{attrs:{id:"分区放置策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区放置策略"}},[t._v("#")]),t._v(" 分区放置策略")]),t._v(" "),v("p",[t._v("首先有一个空闲区表的数据结构，来记录内存的大小和位置，以下是一个空闲区表的结构。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("位置")]),t._v(" "),v("th",[t._v("大小")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("30K")]),t._v(" "),v("td",[t._v("20K")])]),t._v(" "),v("tr",[v("td",[t._v("66K")]),t._v(" "),v("td",[t._v("24K")])]),t._v(" "),v("tr",[v("td",[t._v("118K")]),t._v(" "),v("td",[t._v("12K")])])])]),t._v(" "),v("p",[t._v("分配过程（请求一个s大小的空间）：")]),t._v(" "),v("ol",[v("li",[t._v("从空闲区表的第1个区开始，寻找大于等于s的空闲区。")]),t._v(" "),v("li",[t._v("找到后从分区中分割出s供用户使用。")]),t._v(" "),v("li",[t._v("将剩余部分依然作为空闲区登记在空闲区表内。"),v("br"),t._v("\n由于需要遍历空闲区表，因此需要对空闲区表进行合理的排序，称为放置策略，可以按照首地址大小排序、空闲区大小排序等待")])]),t._v(" "),v("p",[t._v("当内存使用完后需要进行分区回收，分区回收有回收算法，要考虑释放区与现有空闲区是否相邻，如果释放区与现有空闲区不相邻，则直接插入空闲区表，如果相邻，则进行合并")]),t._v(" "),v("h3",{attrs:{id:"内存覆盖技术（overlay）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存覆盖技术（overlay）"}},[t._v("#")]),t._v(" 内存覆盖技术（Overlay）")]),t._v(" "),v("p",[t._v("在较小的内存空间中，运行较大的程序。")]),t._v(" "),v("ul",[v("li",[t._v("内存分区：\n"),v("ul",[v("li",[t._v("常驻区：被某段程序单独且固定地占用，可划分多个")]),t._v(" "),v("li",[t._v("覆盖区：能被多段程序共用（覆盖），可划分多个"),v("br"),t._v(" "),v("img",{attrs:{src:s(578),alt:"5ef86797976994881f3284931669e952"}})])])])]),t._v(" "),v("p",[t._v("覆盖的缺点就是程序员需要划分程序模块并且确定覆盖关系。")]),t._v(" "),v("h3",{attrs:{id:"内存交换技术（swapping）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存交换技术（swapping）"}},[t._v("#")]),t._v(" 内存交换技术（Swapping）")]),t._v(" "),v("p",[t._v("内存不够时，把进程写到磁盘上；当进程要运行的时候，重新写回内存。")]),t._v(" "),v("p",[t._v("换出与换入的地址重定位示意："),v("br"),t._v(" "),v("img",{attrs:{src:s(579),alt:"8ee7010b12454bce75598152769eb275"}})]),t._v(" "),v("h3",{attrs:{id:"内存碎片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片"}},[t._v("#")]),t._v(" 内存碎片")]),t._v(" "),v("p",[t._v("动态分区容易产生内存碎片：内存反复分配和分割"),v("br"),t._v("\n最佳适应法最容易产生碎片（按内存大小分片）。")]),t._v(" "),v("h4",{attrs:{id:"解决办法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[t._v("#")]),t._v(" 解决办法")]),t._v(" "),v("ul",[v("li",[t._v("规定门限：分割空闲区时，如果某一部分小于门限，则空闲区不进行分割，而是全部分配给用户。")]),t._v(" "),v("li",[t._v("内存拼接技术：将所有的空闲区集中在一起构成一个大的空闲区")]),t._v(" "),v("li",[t._v("解除程序占用连续内存才能运行的限制")])])])}),[],!1,null,null,null);a.default=_.exports}}]);