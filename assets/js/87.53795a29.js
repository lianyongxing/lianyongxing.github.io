(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{684:function(a,e,v){"use strict";v.r(e);var _=v(44),r=Object(_.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"分布式概要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式概要"}},[a._v("#")]),a._v(" 分布式概要")]),a._v(" "),v("h2",{attrs:{id:"三大部分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三大部分"}},[a._v("#")]),a._v(" 三大部分")]),a._v(" "),v("ul",[v("li",[a._v("分布式存储")]),a._v(" "),v("li",[a._v("分布式计算")]),a._v(" "),v("li",[a._v("分布式管理")])]),a._v(" "),v("h3",{attrs:{id:"分布式存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式存储"}},[a._v("#")]),a._v(" 分布式存储")]),a._v(" "),v("ol",[v("li",[a._v("结构化存储")]),a._v(" "),v("li",[a._v("非结构化存储")]),a._v(" "),v("li",[a._v("半结构化存储")]),a._v(" "),v("li",[a._v("In-memory存储")])]),a._v(" "),v("p",[a._v("一系列理论、算法、技术")]),a._v(" "),v("p",[a._v("例如Paxos、CAP、Consistent Hash、Timing、2PC、3PC等等。")]),a._v(" "),v("h4",{attrs:{id:"结构化存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构化存储"}},[a._v("#")]),a._v(" 结构化存储")]),a._v(" "),v("p",[a._v("典型场景是事务处理系统或关系型数据库。传统的结构化存储系统强调：")]),a._v(" "),v("ul",[v("li",[a._v("结构化的数据（关系表）")]),a._v(" "),v("li",[a._v("强一致性（银行系统，电商）")]),a._v(" "),v("li",[a._v("随机访问（索引，CURD，SQL）")])]),a._v(" "),v("p",[a._v("正是由于这些限制，结构化存储系统的可扩展性都不太好，一定程度限制了结构化存储在大数据情况下的表现。")]),a._v(" "),v("h4",{attrs:{id:"非结构化存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非结构化存储"}},[a._v("#")]),a._v(" 非结构化存储")]),a._v(" "),v("p",[a._v("非结构化存储与结构化存储不同，强调的是"),v("u",[a._v("高可扩展性")]),a._v("，典型的是分布式文件系统。早期分布式文件系统只是起到网络磁盘的作用，GFS迈出了里程碑的一步：")]),a._v(" "),v("ul",[v("li",[a._v("用master来管理metadata")]),a._v(" "),v("li",[a._v("文件使用64MB的chunks来存储，并在不同的server上保存多个副本")]),a._v(" "),v("li",[a._v("自动容错，自动恢复错误")])]),a._v(" "),v("p",[a._v("GFS设计最初目的是存储海量的日志文件以及网页等文本信息，并进行处理（MAPREDUCE）。和结构化存储相比，虽然分布式文件系统的可扩展性和吞吐率都很好，但几乎无法支持"),v("u",[a._v("随机访问操作")]),a._v("，通常只能进行"),v("u",[a._v("文件的追加操作")]),a._v("。这样的限制使得非结构化存储系统很难面临那些低延时、实时性强的应用。")]),a._v(" "),v("h4",{attrs:{id:"半结构化存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#半结构化存储"}},[a._v("#")]),a._v(" 半结构化存储")]),a._v(" "),v("p",[a._v("半结构化存储的提出是为了解决非结构化存储系统随机访问性能差的问题，一些相关的名词：nosql、key-value store。Nosql系统既有分布式文件系统的可扩展性，又有结构化存储系统的随机访问能力，例如update，read等操作，系统在设计时通常选择简单的k-v进行存储，抛弃了传统RDBMS里复杂的SQL以及ACID事务。这样做可以换取系统最大的限度的可扩展性和灵活性。")]),a._v(" "),v("h4",{attrs:{id:"in-memory存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#in-memory存储"}},[a._v("#")]),a._v(" In-memory存储")]),a._v(" "),v("p",[a._v("随业务并发提高，存储系统对低延迟的要求越来越高，由于摩尔定律及内存价格下降，基于内存的存储系统也开始普及。In-memory存储就是将输出存储在内存中，从而获得读写的高性能。比较有名的memcached、redis。这些基于k-v键值系统的主要目的是为基于磁盘的存储系统做cache，")]),a._v(" "),v("h4",{attrs:{id:"newsql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#newsql"}},[a._v("#")]),a._v(" NewSQL")]),a._v(" "),v("p",[a._v("单机RDBMS在可扩展性上面临问题，Nosql不能很好地支持关系模型。那么有没有既能兼备RCBMS的特性（如SQL支持、ACID事务支持），又像Nosql那要具有可扩展能力呢？2012年Google发表Spanner，以及2013年发表的F1，看到了这种可能性，但是这些系统都太黑科技了。比如，Spanner里用原子钟来解决时钟同步问题，打破光速限制。。。")]),a._v(" "),v("h3",{attrs:{id:"分布式计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式计算"}},[a._v("#")]),a._v(" 分布式计算")]),a._v(" "),v("p",[a._v("分布式计算和并行计算是一回事吗？？")]),a._v(" "),v("p",[a._v("传统的并行计算：投入更多机器，数据大小不变，计算速度更快（高性能）")]),a._v(" "),v("p",[a._v("分布式计算：投入更多机器，处理更大数据（可扩展性）")]),a._v(" "),v("ul",[v("li",[a._v("基于传统的msg系统")]),a._v(" "),v("li",[a._v("MapReduce-like系统")]),a._v(" "),v("li",[a._v("图计算系统")]),a._v(" "),v("li",[a._v("基于状态（state）系统")]),a._v(" "),v("li",[a._v("Streaming系统")])]),a._v(" "),v("h4",{attrs:{id:"基于传统的msg系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基于传统的msg系统"}},[a._v("#")]),a._v(" 基于传统的msg系统")]),a._v(" "),v("p",[a._v("比较有代表性的就是MPI（message passing interface）。目前比较流行的两个MPI实现是mpich2和openmpi。MPI框架非常灵活，对程序结构几乎没有约束。"),v("br"),a._v("\n一个MPI程序，包含多个进程，每个mpi进程都运行一份相同的代码，进程的行为由通讯域（communication world）和该通讯域下的id所决定。")]),a._v(" "),v("p",[a._v("MPI的编程方式：“一处代码，多处执行。”")]),a._v(" "),v("p",[a._v("MPI中的 AllReduce 接口在很多机器学习系统开发里都很常用。因为很多并行机器学习系统都是各个进程分别训练模型，然后再合适的时候（例如一轮迭代结束）大家同步一下答案，达成共识，然后继续迭代。这个 “达成共识” 的操作往往可以很方便的通过 AllReduce 来完成。 AllReduce 接口具有两个优点：")]),a._v(" "),v("ol",[v("li",[a._v("高效。")]),a._v(" "),v("li",[a._v("实用简单。")])]),a._v(" "),v("p",[a._v("但是在实际大规模计算中用的很少，就是因为MPI不支持容错。")]),a._v(" "),v("h4",{attrs:{id:"mapreduce-like系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mapreduce-like系统"}},[a._v("#")]),a._v(" MapReduce-like系统")]),a._v(" "),v("p",[a._v("这类系统又叫做dataflow系统，其中以MapReduce（Hadoop）和Spark为代表，还有很多类似的系统如Dryad、FlumeJava、Twister等，这一系列系统的特点是将计算抽象成high-level operator，例如像map、reduce、filter这样的函数算子，然后将算子组合成DAG，然后由后端的调度引擎进行并行化调度。其中，MapReduce属于比较简单的DAG。只有map和reduce两层节点。Mapreduce之所以可以扩展到超大规模的集群上运行，就是其具备完备的容错机制。Hadoop社区还有很多mapreduce框架衍生品，比如Hive、Pig等。")]),a._v(" "),v("p",[a._v("MapReduce-like的编程风格与MPI相反，对程序的结构由严格的约束——计算过程必须能在两个函数中进行描述：Map和reduce，输入和输出数据都必须是一个个records：任务见不能同心，整个计算过程中唯一的通信机会是map phase和reduce phase之间的shuffling phase，这是在框架控制下的，而不是应用代码控制的，因为有了严格的控制，系统框架在任何时候出错都可以从上个状态恢复，Spark的RDD则是利用Lineage，可以让数据在内存中完成转换。")]),a._v(" "),v("p",[a._v("由于良好的可扩展性，许多人将机器学习算法的并行化任务放在了这些平台上，比较有名的库是Mahout（基于Hadoop），以及MLI（基于Spark）。")]),a._v(" "),v("p",[a._v("但是这些系统有两大缺点：")]),a._v(" "),v("ul",[v("li",[a._v("能支持的机器学习模型都不是很大，这类系统在push back机器学习模型时都是以粗粒度把整个模型进行回传，导致网络通信的瓶颈，有些机器学习的模型很大很大。")]),a._v(" "),v("li",[a._v("严格的"),v("strong",[a._v("BSP同步")]),a._v("计算使得集群的效率变得很低，系统很容易收到straggle的影响")])]),a._v(" "),v("h4",{attrs:{id:"图计算系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图计算系统"}},[a._v("#")]),a._v(" 图计算系统")]),a._v(" "),v("p",[a._v("图计算系统是分布式计算里的一个分支，这些系统将计算过程抽象成图，然后在不同节点分布式执行，例如PageRank，很适合用图来表示，最早成名的图计算是Google的Pregel，该系统采用BSP模型，计算及vectex为中心。随后又出现了一系列图计算框架，例如GPS，Giraph/Hama都是基于BSP图计算项目")]),a._v(" "),v("p",[a._v("除了同步（BSP）图计算系统之外，异步图计算系统里有GraphLab，该系统提出了GAS模型，目前改名为dato，专门推广基于图的大规模机器学习系统")]),a._v(" "),v("h4",{attrs:{id:"基于状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基于状态"}},[a._v("#")]),a._v(" 基于状态")]),a._v(" "),v("p",[a._v("这类系统包括Piccolo，以及后来distbelief，再到后来广泛应用的Parameter Server这个架构")]),a._v(" "),v("p",[a._v("MPI由于不支持容错所以很难扩展到大规模集群中，MapReduce系统无法支持大规模机器学习英语，并且节点同步效率低，用图抽象来做机器学习任务，很多问题都不能很好地求解，比如深度学习中的多层结构。Parameter Server这种state-centric模型将机器学习的模型存储参数上升为主要组件，并采用异步机制提升处理能力。参数服务器的概念最早来自于2010年提出的并行LDA架构，它采用分布式的memcached作为存放参数的存储，这样提供了有效的机制作用与不同worker节点同步模型参数。Google后来2012提出新一代google brain大规模神经网络的解决方案distbelief。")]),a._v(" "),v("h4",{attrs:{id:"streaming系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#streaming系统"}},[a._v("#")]),a._v(" Streaming系统")]),a._v(" "),v("p",[a._v("为流式数据提供服务，系统包括storm、spark streaming、flink等。")]),a._v(" "),v("h3",{attrs:{id:"分布式管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式管理"}},[a._v("#")]),a._v(" 分布式管理")]),a._v(" "),v("p",[a._v("暂无")])])}),[],!1,null,null,null);e.default=r.exports}}]);