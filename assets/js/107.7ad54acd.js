(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{724:function(t,a,v){"use strict";v.r(a);var _=v(44),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),v("h2",{attrs:{id:"死锁的必要条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁的必要条件"}},[t._v("#")]),t._v(" 死锁的必要条件")]),t._v(" "),v("ul",[v("li",[t._v("互斥条件：进程间互相使用资源，资源具有独占性，在一段时间内，资源仅为一个进程占有")]),t._v(" "),v("li",[t._v("不可剥夺条件：进程访问完资源前不能被其他进程强行剥夺")]),t._v(" "),v("li",[t._v("部分分配条件：申请新资源时，不释放已占有的资源")]),t._v(" "),v("li",[t._v("环路条件：多个进程构成环路")])]),t._v(" "),v("h2",{attrs:{id:"解决死锁的策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决死锁的策略"}},[t._v("#")]),t._v(" 解决死锁的策略")]),t._v(" "),v("ul",[v("li",[t._v("预防死锁")])]),t._v(" "),v("ol",[v("li",[t._v("破坏互斥条件（难）：资源固有排他性")]),t._v(" "),v("li",[t._v("破坏不剥夺条件（代价高）：会造成系统及其不稳定")]),t._v(" "),v("li",[t._v("破坏部分分配条件（预先静态分配算法）")]),t._v(" "),v("li",[t._v("破坏环路条件（有序资源分配算法）")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("避免死锁"),v("br"),t._v("\n不事先采取限制去破坏产生死锁的条件，而是在资源分配中，用某种方法去评估，如果分配资源是否会让系统陷入死锁，如果是，则拒绝分配资源，从而避免死锁发生（银行家算法）")])]),t._v(" "),v("li",[v("p",[t._v("检测和恢复死锁"),v("br"),t._v("\n允许死锁发生，但可以通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁清除，将进程从死锁中解放出来")])])]),t._v(" "),v("h3",{attrs:{id:"预先静态分配法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#预先静态分配法"}},[t._v("#")]),t._v(" 预先静态分配法")]),t._v(" "),v("p",[t._v("一个进程只有等到所有资源都备齐后才开始执行")]),t._v(" "),v("h3",{attrs:{id:"有序资源分配法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序资源分配法"}},[t._v("#")]),t._v(" 有序资源分配法")]),t._v(" "),v("p",[t._v("给系统中的每个资源都分配一个序号，进程每次申请资源的时候只能申请序号更大的资源")]),t._v(" "),v("p",[t._v("例如：进程A和进程B，使用资源的顺序分别是R1，R2和R2，R1，如果采用有序资源分配法，则进程A和进程B申请资源的顺序均为R1、R2")]),t._v(" "),v("h3",{attrs:{id:"windows和linux都不处理死锁，留给用户去处理！！"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#windows和linux都不处理死锁，留给用户去处理！！"}},[t._v("#")]),t._v(" Windows和Linux都不处理死锁，留给用户去处理！！")])])}),[],!1,null,null,null);a.default=s.exports}}]);